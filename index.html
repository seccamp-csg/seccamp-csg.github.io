<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>コミュニティ支援G — 人と人を繋ぐ</title>
    <meta name="theme-color" content="#0084FF" />
    <link rel="stylesheet" href="css/global.css" />
    <link rel="stylesheet" href="css/index.css" />
  </head>
  <body>
    <header class="site-header">
      <div class="brand">コミュニティ支援G</div>
      <nav class="site-nav">
        <a href="index.html">ホーム</a>
        <a href="#about">私たちについて</a>
        <a href="#events">イベント</a>
        <a href="#contact">お問い合わせ</a>
      </nav>
    </header>

    <main>
      <section class="hero">
        <canvas id="bg"></canvas>
        <div class="hero-content">
          <h1>セキュリティキャンプで培った<br />技術と仲間をつなぐ。</h1>
          <p>
            セキュリティ・キャンプ修了生の交流と支援を促進するワーキンググループです
          </p>
          <div class="cta-row">
            <a class="btn" href="#about">詳しく見る</a>
            <a class="btn ghost" href="#events">イベントを見る</a>
          </div>
        </div>
      </section>
      <section class="article-list" id="news">
        <div>
          <h2>最新情報</h2>
          <ul>
            <li>
              <div class="article-meta">
                <time datetime="2024-06-15">2024年6月15日</time>
                <a href="#" class="article-title">
                  コミュニティ支援Gのウェブサイトを公開しました
                </a>
              </div>
              <a href="#" class="btn2 small"> 詳しく見る </a>
            </li>
          </ul>
        </div>
      </section>
    </main>

    <footer>
      <p>&copy; 2025 セキュリティ・キャンプ協議会コミュニティ支援グループ</p>
    </footer>

    <script>
      // Particle network background
      (() => {
        const canvas = document.getElementById("bg");
        const ctx = canvas.getContext("2d");

        let w = (canvas.width = window.innerWidth);
        let h = (canvas.height = window.innerHeight);
        const DPR = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = w * DPR;
        canvas.height = h * DPR;
        canvas.style.width = w + "px";
        canvas.style.height = h + "px";
        ctx.scale(DPR, DPR);

        const config = {
          count: Math.round((w * h) / 90000) * 30 || 80,
          maxLink: 120,
          speed: 0.36,
          nodeSize: [2.5, 5],
          colors: {
            node:
              getComputedStyle(document.documentElement)
                .getPropertyValue("--accent")
                .trim() || "#0366d6",
            line:
              getComputedStyle(document.documentElement)
                .getPropertyValue("--line")
                .trim() || "#8fdcff",
          },
        };

        let mouse = { x: null, y: null, radius: 120 };

        function rand(min, max) {
          return Math.random() * (max - min) + min;
        }

        class Node {
          constructor() {
            this.reset();
          }
          reset() {
            this.x = rand(0, w);
            this.y = rand(0, h);
            const angle = rand(0, Math.PI * 2);
            const speed = rand(0.1, config.speed);
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.r = rand(config.nodeSize[0], config.nodeSize[1]);
          }
          update() {
            this.x += this.vx;
            this.y += this.vy;
            if (this.x < -10 || this.x > w + 10) this.vx *= -1;
            if (this.y < -10 || this.y > h + 10) this.vy *= -1;
          }
          draw() {
            ctx.beginPath();
            ctx.fillStyle = config.colors.node;
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        let nodes = [];

        function init() {
          w = canvas.width = window.innerWidth * DPR;
          h = canvas.height = window.innerHeight * DPR;
          canvas.width = window.innerWidth * DPR;
          canvas.height = window.innerHeight * DPR;
          canvas.style.width = window.innerWidth + "px";
          canvas.style.height = window.innerHeight + "px";
          ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

          nodes = [];
          const N = Math.min(
            120,
            Math.max(
              30,
              Math.round((window.innerWidth * window.innerHeight) / 120000)
            )
          );
          for (let i = 0; i < N; i++) nodes.push(new Node());
        }

        function connect() {
          for (let i = 0; i < nodes.length; i++) {
            const a = nodes[i];
            for (let j = i + 1; j < nodes.length; j++) {
              const b = nodes[j];
              const dx = a.x - b.x;
              const dy = a.y - b.y;
              const d2 = dx * dx + dy * dy;
              const max = config.maxLink * config.maxLink;
              if (d2 < max) {
                const alpha = 1 - d2 / max;
                // use configured line color with alpha
                const lineColor = config.colors.line.replace("#", "");
                // fallback if not hex
                ctx.strokeStyle = `rgba(143,220,255,${alpha * 0.9})`;
                ctx.lineWidth = 1.1 * alpha;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();
              }
            }
            // mouse link
            if (mouse.x !== null) {
              const dxm = a.x - mouse.x;
              const dym = a.y - mouse.y;
              const d2m = dxm * dxm + dym * dym;
              const maxm = mouse.radius * mouse.radius;
              if (d2m < maxm) {
                const alpha = 1 - d2m / maxm;
                ctx.strokeStyle = `rgba(3,102,214,${alpha * 0.9})`;
                ctx.lineWidth = 1.2 * alpha;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(mouse.x, mouse.y);
                ctx.stroke();
              }
            }
          }
        }

        function animate() {
          ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
          // lighter background gradient for bright theme
          const b1 =
            getComputedStyle(document.documentElement)
              .getPropertyValue("--bg-1")
              .trim() || "#f0fbff";
          const b2 =
            getComputedStyle(document.documentElement)
              .getPropertyValue("--bg-2")
              .trim() || "#e6f7ff";
          const grd = ctx.createLinearGradient(
            0,
            0,
            window.innerWidth,
            window.innerHeight
          );
          grd.addColorStop(0, b1);
          grd.addColorStop(1, b2);
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

          for (const n of nodes) {
            n.update();
            // draw with configured node color
            ctx.beginPath();
            ctx.fillStyle = config.colors.node;
            ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
            ctx.fill();
          }
          connect();

          requestAnimationFrame(animate);
        }

        window.addEventListener("resize", () => {
          init();
        });

        window.addEventListener("mousemove", (e) => {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
        });

        window.addEventListener("mouseout", () => {
          mouse.x = null;
          mouse.y = null;
        });

        init();
        animate();
      })();
    </script>
  </body>
</html>
